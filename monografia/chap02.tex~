\chapter{Modelagem}
\label{cap:modelagem}

Neste capítulo, é descrito um novo modelo para o problema proposto o qual será a base para os algoritmos introduzidos nos Capítulos 3 e 4. Em seguida, é apresentado como as interferências foram modeladas, como os testes de interferência são definidos e uma propriedade decorrente da modelagem que nos ajudará a garantir menores complexidades de tempo.


\section{Árvore de Combinações}

Seja um grafo direcionado $G=(V,E)$ que representa uma rede mesh sem fio com seus dispositivos e enlaces de comunicação ativos. O conjunto de arestas E representa todas as possibilidades de enlaces ativos para essa rede. É possível definir um subconjunto $C$ de $E$ escolhendo quais enlaces estão ativos ou não. Com isso, tem-se que o menor tamanho de $C$ é zero, ou seja, não há enlaces ativos ($C=\emptyset$), e o maior tamanho de $C$ é o próprio $E$ com todos os enlaces possíveis ativos ($C=E$). Entre esses dois extremos, existem $2^m$ combinações de enlaces possíveis, que são subconjuntos de $E$ definidos pela escolha de quais enlaces estão ativos.

Sobre essas combinações de enlaces é possível definir uma árvore de combinações. Se $m_{c} = |C|$ então para uma altura $h=m_{c}$ da árvore, o número de conjuntos possíveis com tamanho $m_{c}$ é dado por $C(h,m)$. Nessa árvore, parte-se da combinação vazia $(m_{c}=0)$ como raiz ($h=0$). Os filhos de qualquer vértice $C$ da árvore são obtidos combinando $C$ com um enlace $i \in E$, tal que $i \ni C$. 

A ordem em que os enlaces são alocados nos conjuntos não é relevante nesse caso, de forma que se $C=\{e_{1}, e_{2}\}$ e $C'=\{e_{2},e_{1}\}$, então $C \equiv C'$, ou seja, $C$ e $C'$ são equivalentes. Se as combinações equivalentes fossem consideradas na árvore, o número de conjuntos a ser testado iria desnecessariamente aumentar muito. Por isso, ao construir a árvore, apenas uma das combinações equivalentes é incluída. É apresentado na Figura 2.1 um exemplo de árvore de combinações com a estrutura descrita para $m=3$.
%Figura~\ref{fig:arvoreCombinacoes}


%FIGURA Árvore de Combinações para m=3
%\label{fig:arvoreCombinacoes}


No contexto de árvore de combinações, é importante definir também os descendentes e os ancestrais de um vértice. Um descendente de um vértice $u$ em uma árvore é qualquer vértice $v$ que pode ser alcançado a partir de $u$ por algum caminho na árvore. Analogamente, $u$ é ancestral de $v$ se, e somente se, $v$ é descendente de $u$. 
A abstração de árvore de combinações permite que os conjuntos de enlaces sejam percorridos conforme a estrutura da árvore. Com isso é possível desenvolver métodos sistemáticos para buscar e avaliar a viabilidade das combinações de enlaces. Os métodos mais famosos como Busca em Largura e Busca em Profundidade em árvores podem ser considerados nesse caso. Entretanto, sua utilização exige a construção prévia da árvore que apresenta alta complexidade tanto de tempo, quanto de espaço ($O(2^m)$ em ambos os casos).

Os algoritmos que serão apresentados nos próximos capítulos apenas usam a ideia de árvore de combinações em seus projetos. Não há construção da árvore para realizar buscas e isso representa uma diminuição considerável na complexidade de espaço. Além disso, eles fazem uso da propriedade apresentada na próxima seção que por sua vez ajuda a reduzir a complexidade de tempo.


\section{Modelos de Interferência}

No capítulo anterior, o teste de interferência foi descrito de maneira intuitiva e pouco detalhada. Nessa seção, eles serão definidos formalmente e uma propriedade decorrente da natureza desses testes será apresentada. Essa propriedade é importante pois permitirá a confecção de algoritmos de enumeração com melhores desempenhos no futuro. 

\subsection{Modelo de Interferência Primária}

Existem duas características dos enlaces que limitam a comunicação entre os nós em uma rede sem fio: 


\begin{enumerate}

\item Enlaces {\it half-duplex}: Em canais {\it half-duplex}, os rádios dos dispositivos que compõem a rede não podem transmitir e receber mensagens ao mesmo tempo. Por isso, um nó pode apenas ser ou transmissor ou receptor em um dado cenário.
 
\item Enlaces dedicados: Apesar das mensagens serem transmitidas em várias direções e, portanto, alcançando diversos nós, elas são direcionadas a apenas um nó específico. 
\end{enumerate}

Ao modelar uma rede em que os enlaces possuam essas duas características, os nós apenas assumem papel de transmissor ou de receptor em, no máximo, um enlace. Alguns casos que possuem ou não as características I e II são ilustrados na Figura 2.2.

%Figura 2.2: Exemplos de redes em que (a) a condição I é quebrada; (b) a condição II é quebrada; e (c) as condições I e II são atendidas.


Seja $i$ um enlace de um conjunto $C \subset E$. O nó transmissor e o nó receptor de $i$ são, respectivamente, $s_{i}$ e $r_{i}$. Dizemos que $C$ passa no {\bf Teste de Interferência Primária} (TIP)\abbrev{TIP}{Teste de Interferência Primária} se, e somente se, $\forall i,j \in C, s_{i} \neq s_{j} \& s_{i} \neq r_{j} \& r_{i} \neq s_{j} \& r_{i} \neq r_{j}$. 

\section{Modelo de Interferência Secundária}

Como mencionado no capítulo anterior, o meio de transmissão é compartilhado, então o nó transmissor em um enlace pode interferir nos nós receptores de outros enlaces. Contudo, existe um limite de interferência aceitável que é baseado na SINR ({\it Signal to Interference plus Noise Ratio}) \abbrev{SINR}{Signal to Interference plus Noise Ratio}  dos nós receptores. Antes de definir a SINR, algumas outras definições se fazem necessárias.

A primeira delas é a Potência de Recepção $RP(s,r)$ que é a potência com que um sinal transmitido por um nó transmissor $s$ a uma potência de transmissão $TP$ é recebido em um nó $r$ seguindo o modelo de propagação. Matematicamente,

\begin{equation}
RP(s,r) = \frac{TP}{(\frac{d_{sr}}{d_{0}})^{\alpha}}
\end{equation}


onde $\alpha$ é o coeficiente e $d_{0}$ é a distância de referência do modelo de propagação.

Com isso, dado um nó receptor $r_{i}$, consegue-se calcular a potência de recepção em $r_{i}$ em duas situações distintas:

\begin{itemize}

\item quando o sinal é transmitido por $s_{i}$, ou seja, é a potência de recepção dentro do próprio enlace $i$. 
\item quando o sinal é transmitido por $s_{j}$, tal que $j \neq i$, ou seja, é a potência de recepção de um sinal transmitido em um outro enlace $j$. Nesse caso, a potência de recepção de tais sinais é chamada de interferência. 

\end{itemize}

Denomina-se Interferência Total $I(i,C)$ a soma das interferências que os nós transmissores de todos os outros enlaces de $C$ exercem sobre o nó receptor do enlace $i$. Ou seja,


\begin{equation}
I(i,C) = \sum_{j \neq i} RP(s_{j},r_{i})
\end{equation}


Finalmente, a $SINR(i,C)$ é a razão entre a potência de recepção em $r_{i}$ referente a transmissão no enlace $i$ e a interferência causada pelo ruido do ambiente $\gamma$ e a interferência total dos outros enlaces no conjunto $C$.


\begin{equation}
SINR(i,C) = \frac{RP(s_{i},r_{i})} {\gamma + I(i,C)}
\label{eq:sinr}  
\end{equation}


Dado um conjunto de enlaces $C$ e tendo calculado $SINR(i,C)$, $\forall i \in C$, deve-se comparar os valores encontrados com uma constante $\beta$, que representa um valor numérico para o limite de interferência tolerado. Se a interferência for muito alta, o valor do denominador na Equação~\ref{eq:sinr} irá aumentar, fazendo o valor da $SINR(i,C)$ diminuir. Portanto, $\beta$ é um limite inferior, tal que, se $SINR(i,C) \geq \beta$ , $\forall i \in C$, então $C$ passa no Teste de Interferência Secundária (TIS)\abbrev{TIS}{Teste de Interferência Secundária}.

Nesse trabalho, os seguintes valores para as constantes foram usados: $\alpha = 4.0$, $\beta = YYY$ e $\gamma=XXX$.


\subsection{Inviabilidade Hereditária}

Dados os modelos de interferência apresentados, se um conjunto de enlace $C$ passar em ambos os testes, então diz-se que $C$ é viável. Entretanto, nesta subseção, será analisado o que acontece quando C não é viável.
    Em um primeiro cenário, assume-se que $C$ não passou no TIP. Nesse caso, pelo menos um nó de $C$ está participando de mais de um enlace, o que é proibido. Seja um conjunto $C'$, tal que $C' = C \cup {i}$, onde $i \in E$. A adição do novo enlace $i$ em $C$ pode: ({\bf i}) conectar dois nós contidos em $C$; ({\bf ii}) conectar um nó existente em $C$ a um novo nó; e ({\bf iii}) incluir dois novos nós conectados por $i$. 
  
Nas três situações descritas anteriormente, a adição do novo enlace $i$ para formar $C'$ não muda o fato de que $C$ não é viável, independentemente do efeito que $i$ cause no conjunto original $C$. Consequentemente, é possível notar que $C'$ também não é viável.

Em um segundo cenário, assume-se que $C$ passou no TIP, mas não passou no TIS. Nesse caso, $SINR(i,C) < \beta$, para algum enlace $i$. Seja um conjunto $C'$, tal que, $C' = C \cup {j}$, onde $j \in E$ e $C'$ também passa no TIP. A adição de um novo enlace ao conjunto $C$ para formar $C'$, apenas fará aumentar a interferência nos enlaces já contidos em $C$. Mesmo que a contribuição na interferência total seja pequena, podendo até ser desprezada, a 


adição de um novo enlace não muda o fato de que $C$ não é viável. Consequentemente, é possível notar que $C'$ também não é viável.

Os dois cenários apresentados garantem a seguinte propriedade: se um conjunto $C$ não é viável, independentemente de qual teste de interferência ele falhou, então qualquer conjunto $C'$, tal que $C \subset C'$ também não é viável. Usando o modelo de árvore de combinações apresentado na seção anterior, se uma combinação $C$ da árvore de combinações não é viável, então todos os seus descendentes na árvore também não são viáveis. Por isso, essa propriedade é denominada Inviabilidade Hereditária. 

Devido a Inviabilidade Hereditária, no processo de busca e verificação de viabilidade de todas as combinações de enlaces de uma rede, sabe-se que, ao encontrar qualquer combinação não viável, não é necessário testar a viabilidade de nenhum de seus descendentes. O ato de não testar os descendentes de uma combinação não viável pode ser chamado de ``podar'' a árvore.

\section{Algoritmo de Viabilidade}

Dado o modelo de interferência descrito na seção 2.2, o algoritmo de viabilidade  é puramente baseado nos testes de interferência primária e secundária. Algoritmos para os testes serão descritos formalmente e serão combinados para gerar o algoritmo de viabilidade final. 

\subsection{Algoritmo para o Teste de Interferência Primária}

A seguir, o algoritmo para o Teste de Interferência Primária, TIP, é formalizado:

\begin{algorithm}[h]
	\SetVline
	{\bf input:} Conjunto de enlaces $C$\\
	\ForEach { $i \in C$}{
		\ForEach { $j \in C$, $j \neq i$}{
			\If { (( $s_{i}==s_{j}$ ) $||$ ( $s_{i}==r_{j}$ ) $||$ ( $r_{i}==s_{j}$ ) $||$ ( $r_{i}==r_{j}$ ))}{
				\Return FALSE
			}
		}
	}
	\Return TRUE
\caption{Algoritmo TIP}
\label{alg:tip}
\end{algorithm}


\subsubsection{Prova de Corretude}

O TIP apenas formaliza o que foi definido na subseção 2.2.1. Portanto, está correto. 

\subsubsection{Análise da Complexidade}

Para o pior caso, $|C|=m$, então a complexidade de tempo é $O(m^2)$. A complexidade de espaço é definida pelo maior tamanho de $C$ possível, portanto, $O(m)$.

\subsection{Algoritmo para o Teste de Interferência Secundária}

A seguir, o algoritmo para o Teste de Interferência Secudária, TIS, é formalizado:

\begin{algorithm}[h]
	\SetVline
	{\bf input:} Conjunto de enlaces $C$\\
	\ForEach { $i \in C$}{
		\If {(( $SINR(i,C)<\beta$ ))}{
			\Return FALSE
		}
	}
	\Return TRUE
\caption{Algoritmo TIS}
\label{alg:tis}
\end{algorithm}

\subsubsection{Prova de Corretude}

O TIS apenas formaliza o que foi definido na subseção 2.2.2. Portanto, está correto.

\subsubsection{Análise da Complexidade}

Como o cálculo da $SINR(i,C)$ é $O(m)$, devido o laço definido na linha 2 iterar sobre no máximo m enlaces, então a complexidade de tempo é $O(m^2)$. Analogamente ao TIP, a complexidade de espaço é $O(m)$.

\subsection{Algoritmo para o Teste de Viabilidade}

O algoritmo para testar a viabilidade de um conjunto de enlaces é simplesmente a junção dos algoritmos anteriores conforme a descrição abaixo:

\begin{algorithm}[h]
	\SetVline
	{\bf input:} Conjunto de enlaces $C$\\
		\If { (TIP) $||$ (TIS)}{
			\Return TRUE
		}
		\Else {
			\Return FALSE
		}
\caption{Algoritmo VIAVEL}
\label{alg:viavel}
\end{algorithm}

\subsubsection{Prova de Corretude}

\subsubsection{Análise da Complexidade}

\section{Exemplo}

O grafo G=(V,E) da Figura 2.3 representa os nós e os enlaces de uma rede mesh sem fio. Deseja-se encontrar os conjuntos de enlaces viáveis dessa rede. 

%Figura 2.3: Rede Mapeada no Grafo G=(V,E)

Nesse exemplo, $E=\{1, 2, 3, 4\}$, ou seja, $m=4$. Portanto, existem $2^4 = 16$ combinações de enlaces que são representados na árvore de combinações da Figura 2.4. Uma Busca em Profundidade será executada para percorrer os vértices da árvore que serão verificados usando o algoritmo VIÁVEL. A ordem em que os vértices são visitados é $\{\{\}, \{1\}, \{1,2\}, \{1,2,3\}, \{1,2,3,4\}, \{1,3\}, \{1,3,4\}, \{1,4\}, \{2\}, \{2,3\}, \{2,3,4\}, \{2,4\},$ $\{3\}, \{3,4\}, \{4\}\}$ e pode ser verificada também na Figura 2.4.

%Figura 2.4: Árvore de Combinações dos Enlaces de G

A Tabela 2.1 mostra o resultado dos testes para cada combinação e a Tabela 2.2 mostra os motivos pelos quais as combinações falharam os testes.

%Tabela 2.1

%Tabela 2.2

Finalmente, os conjuntos de enlaces viáveis obtidos  são: $\{\{\},\{1\},\{2\},\{2,4\},\{3\},\{3,4\},\{4\}\}$. No próximo capítulo, o primeiro algoritmo de  enumeração é introduzido. Trata-se de um algoritmo iterativo que, apesar de seguir a estrutura da árvore, não precisa instanciá-la como foi feito nesse exemplo. No capítulo 4, é apresentada uma outra versão desse algoritmo que, devido sua natureza recursiva, permite que muitos dos cálculos realizados nos testes de interferência sejam poupados.
